# 代码实现及其分析

## 实现功能

一级菜单

 ![img](https://img-blog.csdnimg.cn/87100cc72bf24ed98f185e4b6868fa61.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARnJlYWs1ODc=,size_18,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==) 

用Tree抽象类完成二叉排序树及AVL树的多态及模板实现

其中的多态功能展示：

 ![img](https://img-blog.csdnimg.cn/c562bef721374e2ab0dc68db657203ac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARnJlYWs1ODc=,size_19,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==) 

用Heap抽象类完成大顶堆及小顶堆的多态及模板实现

其中的多态功能展示：

 ![img](https://img-blog.csdnimg.cn/0141c2625ecd4b70a15a83c148c06e8d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARnJlYWs1ODc=,size_17,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==) 

## 代码主要部分

 ![img](https://img-blog.csdnimg.cn/aa3d0f8c66dd4fcf9ace81356737e686.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARnJlYWs1ODc=,size_13,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==) 

有四个筛选器，分别是Heap,Menu,Tree,源文件

其中源文件存放的主函数，是比较简单的。

 ![img](https://img-blog.csdnimg.cn/7aef2e47cd44463aba24e7264e7b439d.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==) 

Menu存放的是菜单的调度函数以及非法输入的检测，和二叉排序树及AVL树，和小顶堆及大顶堆的实现

 ![img](https://img-blog.csdnimg.cn/04f02c590f41419fb19ba1735d22ffb2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARnJlYWs1ODc=,size_14,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==) 

Heap存放的是大顶堆小顶堆的实现，三个文件分别对应，小顶堆、大顶堆及抽象类，下图是抽象类

 ![img](https://img-blog.csdnimg.cn/fbaa2d49b93348719466062a1837584c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARnJlYWs1ODc=,size_13,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==) 

Tree存放的是二叉排序、AVL树的实现以及一个抽象类，下图是该抽象类

 ![img](https://img-blog.csdnimg.cn/40af4c0faa8e4acf874f225b93cb9a7b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARnJlYWs1ODc=,size_18,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==) 

## 关键代码分析

AVL树的右旋转操作：

 ![img](https://img-blog.csdnimg.cn/60e826c3a7744effa92e2956b02e4338.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARnJlYWs1ODc=,size_20,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==) 

 ![img](https://img-blog.csdnimg.cn/70b0bb8a7bd344b5ab7bf22ba80191c4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARnJlYWs1ODc=,size_13,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==) 

右旋转的，如图所示，先把L的右孩成为P的左孩，然后L的右孩接上P（或者说让P成为L的右孩）



 ![img](https://img-blog.csdnimg.cn/c85c9547b76241d2b17c08fe9bdae2b2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARnJlYWs1ODc=,size_20,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==) 



 ![img](https://img-blog.csdnimg.cn/330fb06bd74c49d389965d9ab86a8322.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARnJlYWs1ODc=,size_20,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==) 

对于不是斜树的情况（如上图所示），我们要先转成斜树然后要再旋转一次，也就是说要旋转两次

 ![img](https://img-blog.csdnimg.cn/5d29772b8fa748b1aa40b37492e261d7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARnJlYWs1ODc=,size_20,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==) 

AVL树的插入，因为插入操作会使树深度变大，因而我们建立一个布尔类型的taller来判断是会在哪个双亲或结点长高，然后再根据结点的平衡因子进行旋转。