# 代码实现及思路分析

### 思路分析

1.创建两个类Sort,Menu类及头文件，和三个源文件main,sort,menu,

在Menu头文件实现所有功能函数的调度。其次Menu类还负责管理文件的读取

Sort类负责管理所有排序函数及非法输入处理和输出数据

2.示例图

Menu类：

 ![img](https://img-blog.csdnimg.cn/820232d6fbf84923a36a70ba572cac70.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARnJlYWs1ODc=,size_17,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==) 

Sort类：

 ![img](https://img-blog.csdnimg.cn/8d0ace7a14a7446cb991ceefa19e0c97.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARnJlYWs1ODc=,size_20,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==) 

 ![img](https://img-blog.csdnimg.cn/177a809d188a470592e54421c4cadc6c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARnJlYWs1ODc=,size_19,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==) 

### 主要代码实现

#### 应用题

##### 颜色排序

1.用p1=最前位,p2=最后位，v[i]遇到0与p1交换，遇到2与p2交换

2.但是注意：p1跟v[i]是同向走的，跟p2不同，如果v[i]与0交换后遇到2，或者v[i]与2交换后遇到0，这些情况会导致v【i】不知所措，因而v[i]遇到2交换后要i--，退一位。

3.代码如下：

``` c++
for (int i = 0; i <= p2; i++)
	{
		if (v1[i] == 0)
		{
			swap(v1[i],v1[p1++]);
		}
		else if (v1[i] == 2)
		{
			swap(v1[i--], v1[p2--]);
		}
	}	
```

##### 找第k小/大元素

1.输入要排序的数据量,再输入k

2.然后根据驱轴返回函数是否等于k，若小于k，则改变low位，若大于k，则改变high位，有点像二分法，有点像二叉排序树

3.代码如下，我们先找k小，然后再找k大

``` c++
//输入k
	cout << "请输入你要的第k小/大的元素：" << endl;
	cout << "k=";
	int k;
	cin >> select;
	if ((k = ISNumber(select)) == -1)
	{
		cout << "输入有误！" << endl;
		while (getchar() != '\n')
		{
			;
		}
		system("pause");
		system("cls");
		return;
	}
	cout << endl;

	//-----------------1找第k小
	int high = v1.size() - 1;
	int low = 0;

	//排序及计时
	clock_t begin = clock();
	QuickSort_FindK(v1, low, high, k-1);
	clock_t end = clock();

	//输出数据及计时
	cout << "第"<<k << "小元素为:" << v1[k-1] << endl;
	cout << "此时的数据为：" << endl;
	Print(v1);
	cout << "用时：" <<(double)(end-begin) << "ms" << endl;
	cout << endl;

	//------------------2找第k大
	high = v1.size() - 1;
	low = 0;
	cout << "第" << k << "大元素为:" ;
	k = v1.size() - k;

	//排序及计时
	begin = clock();
	QuickSort_FindK(v1, low, high, k);
	end = clock();

	//输出数据及计时
	cout << v1[k] << endl;
	cout << "此时的数据为：" << endl;
	Print(v1);
	cout << "用时：" << (double)((end - begin))  << "ms" << endl;
	cout << endl;
```

### 问题总结

1.归并排序1月的时候课设有用到，当时用的是快慢指针法，所以这次换一种方法试试

 ![img](https://img-blog.csdnimg.cn/79d03d8c352c4d7a97a6f068d6a83bd8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARnJlYWs1ODc=,size_20,color_FFFFFF,t_70,g_se,x_16)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==) 

2.快速排序的优化

  解决效率低，占内存，栈溢出问题------尾递归

​	解决选取驱轴不平衡----三数取中

​		不稳定排序，数据量少时优势不明显----量少改插入排序

由于时间关系，我仅实现了两个

``` c++
void Sort::QuickSort_Recursion(vector<int>& v1, int low, int high)
{
	int flag;
	while (low < high)
	{
		flag = Partition(v1, low, high);
		QuickSort_Recursion(v1, low, flag - 1);
		low = flag + 1;//尾递归优化
	}

}
int Sort::Partition(vector<int>& v1, int low, int high)
{
	//----三数取中
	int m = low + (high - low) / 2;
	if (v1[low] > v1[high])
		swap(v1[low], v1[high]);
	if (v1[m] > v1[high])
		swap(v1[m], v1[high]);
	if (v1[low] > v1[m])
		swap(v1[low], v1[m]);

	int temp = v1[low];
	while (low < high)
	{
		while (low < high && v1[high] >= temp)
			high--;
		swap(v1[low], v1[high]);
		while (low < high && v1[low] <= temp)
			low++;
		swap(v1[low], v1[high]);
		
	}
	return low;
}
```



3.时间太紧，写好的函数没有充分debug,导致后面不断修改，效率低下，下周要改

4.为了学以致用，多加了堆排序和希尔排序